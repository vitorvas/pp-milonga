#pragma omp for ordered(n) collapse(n)

#pragma omp for ordered(n) depend(sink:...)

#pragma omp for ordered(n) depende(source)

Isso e pra usar doacross pattern de forma paralelizada.
Se estudar com carinho, pode ser que seja util no milonga.

-----------------------------------------------------------------

/home/vitor/software/milonga/wasora/src/mesh/neighbors.c:int mesh_count_common_nodes(element_t *e1, element_t *e2, int *nodes)

Essa eh uma funcao candidata. Ainda eh necessario saber
seu perfil com detalhes, mas no seu corpo
trata-se de um loop que compara nos em comum entre
elementos da malha.

Os nos em comum sao armazenados no vetor nodes.
Um reduce resolve facil isso.
Testar.

-----------------------------------------------------------------

3.2.3 Iteration (Book).

O conceito de loop-carried-dependencies eh um conceito importante na
paralelizacao de loos de iteracao. A funcao escolhida nao apresenta esse
tipo de dependencia. Ao explicar isso no paper, fazer essa referencia.

-----------------------------------------------------------------

Iniciar o processo de profiling considerando consumo de memória e tempo.
Para isso, cada execução de profiling vai ser precedida da execução 
com -O3 (ou -O2) do milonga. Com isso vou poder medir direito o desempenho.

Ver como automatizar isso e conferir, ao mesmo tempo, consumo de memória 
e tempo. E fazer inicialmente apenas para FEM enquanto o FVM não estiver 
100% com o exemplo utilizado. Pretendo usar só um inicialmente.


-----------------------------------------------------------------
Assim para debugar o milonga usando o mpirun. Notar que para cada processo ele vai abrir
um xterm diferente e cada debug será feito em um processo.

mpirun -np 2 xterm -e gdb --args /home/vitors/workspace/development/milonga-vitor/milonga profiling.mil --volumes --diffusion tet-s volumes diffusion
